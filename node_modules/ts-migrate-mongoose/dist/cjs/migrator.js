"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IOptions = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const mongoose_1 = tslib_1.__importDefault(require("mongoose"));
const model_1 = require("./model");
const defaults_1 = require("./defaults");
const template_1 = tslib_1.__importDefault(require("./template"));
const register_1 = require("@swc-node/register/register");
(0, register_1.register)();
exports.IOptions = tslib_1.__importStar(require("./interfaces/IOptions"));
class Migrator {
    constructor(options) {
        mongoose_1.default.set('strictQuery', false);
        this.template = this.getTemplate(options.templatePath);
        this.migrationsPath = node_path_1.default.resolve(options.migrationsPath ?? defaults_1.DEFAULT_MIGRATE_MIGRATIONS_PATH);
        this.collection = options.collection ?? defaults_1.DEFAULT_MIGRATE_MONGO_COLLECTION;
        this.autosync = options.autosync ?? defaults_1.DEFAULT_MIGRATE_AUTOSYNC;
        this.cli = options.cli ?? defaults_1.DEFAULT_MIGRATE_CLI;
        this.ensureMigrationsPath();
        if (options.uri) {
            this.uri = options.uri;
            this.connection = mongoose_1.default.createConnection(this.uri, options.connectOptions);
        }
        else {
            const message = chalk_1.default.red('No mongoose connection or mongo uri provided to migrator');
            throw new Error(message);
        }
        this.migrationModel = (0, model_1.getMigrationModel)(this.connection, this.collection);
    }
    static async connect(options) {
        const migrator = new Migrator(options);
        await migrator.connected();
        return migrator;
    }
    async close() {
        await this.connection.close();
    }
    async list() {
        await this.sync();
        const migrations = await this.migrationModel.find().sort({ createdAt: 1 }).exec();
        if (!migrations.length)
            this.log(chalk_1.default.yellow('There are no migrations to list'));
        return migrations.map((migration) => {
            this.logMigrationStatus(migration.state, migration.filename);
            return migration;
        });
    }
    async create(migrationName) {
        const existingMigration = await this.migrationModel.findOne({ name: migrationName }).exec();
        if (existingMigration) {
            const message = chalk_1.default.red(`There is already a migration with name '${migrationName}' in the database`);
            throw new Error(message);
        }
        await this.sync();
        const now = Date.now();
        const newMigrationFile = `${now.toString()}-${migrationName}.ts`;
        node_fs_1.default.writeFileSync(node_path_1.default.join(this.migrationsPath, newMigrationFile), this.template);
        const migrationCreated = await this.migrationModel.create({
            name: migrationName,
            createdAt: now,
        });
        this.log(`Created migration ${migrationName} in ${this.migrationsPath}`);
        return migrationCreated;
    }
    async run(direction, migrationName, single = false) {
        await this.sync();
        let untilMigration = null;
        const state = direction === 'up' ? 'down' : 'up';
        const key = direction === 'up' ? '$lte' : '$gte';
        const sort = direction === 'up' ? 1 : -1;
        if (migrationName) {
            untilMigration = await this.migrationModel.findOne({ name: migrationName }).exec();
        }
        else {
            untilMigration = await this.migrationModel
                .findOne({ state })
                .sort({ createdAt: single ? sort : -sort })
                .exec();
        }
        if (!untilMigration) {
            if (migrationName) {
                const message = chalk_1.default.red(`Could not find migration with name '${migrationName}' in the database`);
                throw new ReferenceError(message);
            }
            return this.noPendingMigrations();
        }
        const query = {
            createdAt: { [key]: untilMigration.createdAt },
            state,
        };
        const migrationsToRun = [];
        if (single) {
            migrationsToRun.push(untilMigration);
        }
        else {
            const migrations = await this.migrationModel.find(query).sort({ createdAt: sort }).exec();
            migrationsToRun.push(...migrations);
        }
        if (!migrationsToRun.length) {
            return this.noPendingMigrations();
        }
        const migrationsRan = await this.runMigrations(migrationsToRun, direction);
        if (migrationsToRun.length === migrationsRan.length && migrationsRan.length > 0) {
            this.log(chalk_1.default.green('All migrations finished successfully'));
        }
        return migrationsRan;
    }
    async sync() {
        try {
            const { migrationsInFs } = await this.getMigrations();
            let migrationsToImport = migrationsInFs.filter((file) => !file.existsInDatabase).map((file) => file.filename);
            this.log('Synchronizing database with file system migrations...');
            migrationsToImport = await this.choseMigrations(migrationsToImport, 'The following migrations exist in the migrations folder but not in the database.\nSelect the ones you want to import into the database');
            return this.syncMigrations(migrationsToImport);
        }
        catch (error) {
            const message = 'Could not synchronize migrations in the migrations folder up to the database';
            if (error instanceof Error) {
                error.message = `${message}\n${error.message}`;
            }
            throw error;
        }
    }
    async prune() {
        try {
            let migrationsDeleted = [];
            const { migrationsInDb, migrationsInFs } = await this.getMigrations();
            let migrationsToDelete = migrationsInDb.filter((migration) => !migrationsInFs.find((file) => file.filename === migration.filename)).map((migration) => migration.name);
            migrationsToDelete = await this.choseMigrations(migrationsToDelete, 'The following migrations exist in the database but not in the migrations folder.\nSelect the ones you want to remove from the database');
            if (migrationsToDelete.length) {
                migrationsDeleted = await this.migrationModel.find({ name: { $in: migrationsToDelete } }).exec();
                this.log(`Removing migration(s) from database: \n${chalk_1.default.cyan(migrationsToDelete.join('\n'))} `);
                await this.migrationModel.deleteMany({ name: { $in: migrationsToDelete } }).exec();
            }
            return migrationsDeleted;
        }
        catch (error) {
            const message = 'Could not prune extraneous migrations from database';
            if (error instanceof Error) {
                error.message = `${message}\n${error.message}`;
            }
            throw error;
        }
    }
    async noPendingMigrations() {
        this.log(chalk_1.default.yellow('There are no pending migrations'));
        if (this.cli) {
            this.log('Current migrations status: ');
            await this.list();
        }
        return [];
    }
    log(message) {
        if (this.cli) {
            console.log(message);
        }
    }
    logMigrationStatus(direction, filename) {
        this.log(`${chalk_1.default[direction === 'up' ? 'green' : 'red'](`${direction}:`)} ${filename} `);
    }
    getTemplate(templatePath) {
        if (templatePath && node_fs_1.default.existsSync(templatePath)) {
            return node_fs_1.default.readFileSync(templatePath, 'utf8');
        }
        return template_1.default;
    }
    ensureMigrationsPath() {
        if (!node_fs_1.default.existsSync(this.migrationsPath)) {
            node_fs_1.default.mkdirSync(this.migrationsPath, { recursive: true });
        }
    }
    async connected() {
        return this.connection.asPromise();
    }
    async syncMigrations(migrationsInFs) {
        const promises = migrationsInFs.map(async (filename) => {
            const filePath = node_path_1.default.join(this.migrationsPath, filename);
            const timestampSeparatorIndex = filename.indexOf('-');
            const timestamp = filename.slice(0, timestampSeparatorIndex);
            const migrationName = filename.slice(timestampSeparatorIndex + 1, filename.lastIndexOf('.'));
            this.log(`Adding migration ${filePath} into database from file system. State is ${chalk_1.default.red('down')}`);
            return this.migrationModel.create({
                name: migrationName,
                createdAt: timestamp,
            });
        });
        return Promise.all(promises);
    }
    async getMigrations() {
        const files = node_fs_1.default.readdirSync(this.migrationsPath);
        const migrationsInDb = await this.migrationModel.find({}).exec();
        const migrationsInFs = files
            .filter((filename) => /^\d{13,}-/.test(filename) && filename.endsWith('.ts'))
            .map((filename) => {
            const [time] = filename.split('-');
            const timestamp = Number.parseInt(time ?? '');
            const createdAt = new Date(timestamp);
            const existsInDatabase = migrationsInDb.some((migration) => filename === migration.filename);
            return { createdAt, filename, existsInDatabase };
        });
        return { migrationsInDb, migrationsInFs };
    }
    async choseMigrations(migrations, message) {
        if (!this.autosync && migrations.length) {
            const answers = await inquirer_1.default.prompt({
                type: 'checkbox',
                message,
                name: 'chosen',
                choices: migrations,
            });
            return answers.chosen;
        }
        return migrations;
    }
    async runMigrations(migrationsToRun, direction) {
        const migrationsRan = [];
        for await (const migration of migrationsToRun) {
            const migrationFilePath = node_path_1.default.join(this.migrationsPath, migration.filename);
            const migrationFunctions = (await Promise.resolve(`${migrationFilePath}`).then(s => tslib_1.__importStar(require(s))));
            const migrationFunction = migrationFunctions[direction];
            if (!migrationFunction) {
                const message = chalk_1.default.red(`The '${direction}' export is not defined in ${migration.filename}.`);
                throw new Error(message);
            }
            try {
                await migrationFunction();
                this.logMigrationStatus(direction, migration.filename);
                await this.migrationModel
                    .where({ name: migration.name })
                    .updateMany({ $set: { state: direction } })
                    .exec();
                migrationsRan.push(migration);
            }
            catch (error) {
                const message = `Failed to run migration with name '${migration.name}' due to an error`;
                if (error instanceof Error) {
                    error.message = `${message}\n${error.message}`;
                }
                throw error;
            }
        }
        return migrationsRan;
    }
}
exports.default = Migrator;
//# sourceMappingURL=migrator.js.map