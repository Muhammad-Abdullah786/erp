"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = exports.Migrate = exports.getMigrator = exports.getConfig = void 0;
const tslib_1 = require("tslib");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const commander_1 = require("commander");
const dotenv_1 = require("dotenv");
const migrator_1 = tslib_1.__importDefault(require("./migrator"));
const defaults_1 = require("./defaults");
const register_1 = require("@swc-node/register/register");
(0, register_1.register)();
const getConfig = async (configPath) => {
    let fileOptions = {};
    if (configPath) {
        try {
            const file = node_path_1.default.resolve(configPath);
            const module = (await Promise.resolve(`${file}`).then(s => tslib_1.__importStar(require(s))));
            const esm = module.default;
            if (esm?.default) {
                fileOptions = esm.default ?? {};
            }
            else {
                fileOptions = module.default ?? {};
            }
        }
        catch {
            fileOptions = {};
        }
    }
    return fileOptions;
};
exports.getConfig = getConfig;
const getMigrator = async (options) => {
    (0, dotenv_1.config)({ path: '.env' });
    (0, dotenv_1.config)({ path: '.env.local', override: true });
    const mode = options.mode ?? process.env.MIGRATE_MODE ?? process.env.migrateMode;
    if (mode) {
        (0, dotenv_1.config)({ path: `.env.${mode}`, override: true });
        (0, dotenv_1.config)({ path: `.env.${mode}.local`, override: true });
    }
    const configPath = options.configPath ?? process.env.MIGRATE_CONFIG_PATH ?? process.env.migrateConfigPath ?? defaults_1.DEFAULT_MIGRATE_CONFIG_PATH;
    const fileOptions = await (0, exports.getConfig)(configPath);
    const uri = options.uri ?? process.env.MIGRATE_MONGO_URI ?? process.env.migrateMongoUri ?? fileOptions.uri;
    const connectOptions = fileOptions.connectOptions;
    const collection = options.collection ?? process.env.MIGRATE_MONGO_COLLECTION ?? process.env.migrateMongoCollection ?? fileOptions.collection ?? defaults_1.DEFAULT_MIGRATE_MONGO_COLLECTION;
    const migrationsPath = options.migrationsPath ?? process.env.MIGRATE_MIGRATIONS_PATH ?? process.env.migrateMigrationsPath ?? fileOptions.migrationsPath ?? defaults_1.DEFAULT_MIGRATE_MIGRATIONS_PATH;
    const templatePath = options.templatePath ?? process.env.MIGRATE_TEMPLATE_PATH ?? process.env.migrateTemplatePath ?? fileOptions.templatePath;
    const autosync = Boolean(options.autosync ?? process.env.MIGRATE_AUTOSYNC ?? process.env.migrateAutosync ?? fileOptions.autosync ?? defaults_1.DEFAULT_MIGRATE_AUTOSYNC);
    if (!uri) {
        const message = chalk_1.default.red('You need to provide the MongoDB Connection URI to persist migration status.\nUse option --uri / -d to provide the URI.');
        throw new Error(message);
    }
    const migratorOptions = {
        migrationsPath,
        uri,
        collection,
        autosync,
        cli: true,
    };
    if (templatePath) {
        migratorOptions.templatePath = templatePath;
    }
    if (connectOptions) {
        migratorOptions.connectOptions = connectOptions;
    }
    return migrator_1.default.connect(migratorOptions);
};
exports.getMigrator = getMigrator;
class Migrate {
    constructor() {
        this.program = new commander_1.Command();
        this.program
            .name('migrate')
            .description(chalk_1.default.cyan('CLI migration tool for mongoose'))
            .option('-f, --config-path <path>', 'path to the config file')
            .option('-d, --uri <string>', chalk_1.default.yellow('mongo connection string'))
            .option('-c, --collection <string>', 'collection name to use for the migrations')
            .option('-a, --autosync <boolean>', 'automatically sync new migrations without prompt')
            .option('-m, --migrations-path <path>', 'path to the migration files')
            .option('-t, --template-path <path>', 'template file to use when creating a migration')
            .option('--mode <string>', 'environment mode to use .env.[mode] file')
            .hook('preAction', async () => {
            const opts = this.program.opts();
            this.migrator = await (0, exports.getMigrator)(opts);
        });
        this.program
            .command('list')
            .description('list all migrations')
            .action(async () => {
            console.log(chalk_1.default.cyan('Listing migrations'));
            await this.migrator.list();
        });
        this.program
            .command('create <migration-name>')
            .description('create a new migration file')
            .action(async (migrationName) => {
            await this.migrator.create(migrationName);
            console.log(`Migration created. Run ${chalk_1.default.cyan(`migrate up ${migrationName}`)} to apply the migration`);
        });
        this.program
            .command('up [migration-name]')
            .description('run all migrations or a specific migration if name provided')
            .option('-s, --single', 'run single migration', false)
            .action(async (migrationName, options) => {
            await this.migrator.run('up', migrationName, options?.single);
        });
        this.program
            .command('down <migration-name>')
            .description('roll back migrations down to given name')
            .option('-s, --single', 'run single migration', false)
            .action(async (migrationName, options) => {
            await this.migrator.run('down', migrationName, options?.single);
        });
        this.program
            .command('prune')
            .description('delete extraneous migrations from migration folder or database')
            .action(async () => {
            await this.migrator.prune();
        });
    }
    async finish(exit, error) {
        if (this.migrator instanceof migrator_1.default) {
            await this.migrator.close();
        }
        if (error) {
            console.error(chalk_1.default.red(error.message));
            if (exit)
                process.exit(1);
            throw error;
        }
        if (exit)
            process.exit(0);
        return this.program.opts();
    }
    async run(exit = true) {
        return this.program
            .parseAsync(process.argv)
            .then(() => {
            return this.finish(exit);
        })
            .catch((error) => {
            return this.finish(exit, error instanceof Error ? error : new Error('An unknown error occurred'));
        });
    }
}
exports.Migrate = Migrate;
exports.migrate = new Migrate();
//# sourceMappingURL=commander.js.map